<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>K-Means Clustering Demo</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f8f8f8; margin: 0; padding: 0; }
    .container { max-width: 800px; margin: 40px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; padding: 24px; }
    h1 { text-align: center; }
    #controls { display: flex; justify-content: center; gap: 16px; margin-bottom: 16px; }
    button, select { font-size: 1rem; padding: 8px 16px; border-radius: 4px; border: 1px solid #888; background: #eee; cursor: pointer; }
    button:active { background: #ddd; }
    #graph { display: block; margin: 0 auto; background: #fafafa; border: 1px solid #ccc; border-radius: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>K-Means Clustering Demo</h1>
    <div id="controls">
  <label for="num-points">Points:</label>
  <input type="number" id="num-points" min="100" max="1000" value="100" style="width:80px;">
  <label for="k-select">K:</label>
  <select id="k-select"></select>
  <button id="place-centroids">K</button>
  <button id="match">Match</button>
  <button id="move">Move</button>
  <button id="reset">Start Over</button>
    </div>
  <div id="graph" style="width:700px; height:500px;"></div>
  </div>
  <script src="libs/three.min.js"></script>
  <script src="libs/OrbitControls.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {
        document.getElementById('graph').innerHTML = '<div style="color:red;text-align:center;padding:2em;">Failed to load three.js or OrbitControls.<br>Please check your internet connection or CDN access.</div>';
        return;
      }
      // --- Utility Functions ---
      function randFloat(min, max) { return Math.random() * (max - min) + min; }

      // --- State ---
      let points = [];
      let K = 2;

      // --- DOM Elements ---
      const numPointsInput = document.getElementById('num-points');
      const kSelect = document.getElementById('k-select');
      const btnPlace = document.getElementById('place-centroids');
      const btnMatch = document.getElementById('match');
      const btnMove = document.getElementById('move');
      const btnReset = document.getElementById('reset');

      // --- Setup K selector ---
      for (let i = 2; i <= 9; ++i) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i;
        kSelect.appendChild(opt);
      }
      kSelect.value = K;
      kSelect.onchange = () => { K = parseInt(kSelect.value); };

      // --- Generate random 3D points ---
      function genPoints() {
        points = [];
        const N = Math.max(100, Math.min(1000, parseInt(numPointsInput.value) || 100));
        for (let i = 0; i < N; ++i) {
          points.push({
            x: randFloat(-100, 100),
            y: randFloat(-100, 100),
            z: randFloat(-100, 100)
          });
        }
      }

      // --- Three.js Setup ---
  let scene, camera, renderer, controls, pointGroup, centroidGroup;

      function setup3D() {
        const graphDiv = document.getElementById('graph');
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, 700/500, 0.1, 1000);
        camera.position.set(0, 0, 300);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(700, 500);
        graphDiv.innerHTML = '';
        graphDiv.appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.minDistance = 50;
        controls.maxDistance = 600;

        // Add light
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(0, 0, 300);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // Axes helper
        scene.add(new THREE.AxesHelper(120));

        // Points group
        pointGroup = new THREE.Group();
        scene.add(pointGroup);
        // Centroid group
        centroidGroup = new THREE.Group();
        scene.add(centroidGroup);
      }

      let assignments = [];
      function draw3DPoints() {
        // Remove previous points
        while (pointGroup.children.length > 0) {
          pointGroup.remove(pointGroup.children[0]);
        }
        // Add new points
        const geometry = new THREE.SphereGeometry(2.5, 12, 12);
        for (let i = 0; i < points.length; ++i) {
          let color = 0x3498db;
          if (assignments && assignments[i] !== undefined && assignments[i] !== -1) {
            color = centroidColors[assignments[i] % centroidColors.length];
          }
          const material = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(points[i].x, points[i].y, points[i].z);
          pointGroup.add(mesh);
        }
      }

      // --- Centroid logic ---
      let centroids = [];
      const centroidColors = [0xe74c3c, 0x3498db, 0x27ae60, 0xf1c40f, 0x9b59b6, 0x1abc9c, 0xe67e22, 0x34495e, 0xfd79a8];
      function placeCentroids() {
        centroids = [];
        assignments = Array(points.length).fill(-1);
        while (centroidGroup.children.length > 0) {
          centroidGroup.remove(centroidGroup.children[0]);
        }
        for (let i = 0; i < K; ++i) {
          const c = {
            x: randFloat(-100, 100),
            y: randFloat(-100, 100),
            z: randFloat(-100, 100)
          };
          centroids.push(c);
          const geometry = new THREE.SphereGeometry(8, 16, 16);
          const material = new THREE.MeshStandardMaterial({ color: centroidColors[i % centroidColors.length] });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(c.x, c.y, c.z);
          centroidGroup.add(mesh);
        }
        draw3DPoints();
      }

      function dist3D(a, b) {
        return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2);
      }

      function matchPoints() {
        if (centroids.length === 0) return;
        assignments = points.map(p => {
          let minD = Infinity, idx = -1;
          centroids.forEach((c, i) => {
            const d = dist3D(p, c);
            if (d < minD) { minD = d; idx = i; }
          });
          return idx;
        });
        draw3DPoints();
      }

      function moveCentroids() {
        if (centroids.length === 0 || assignments.length === 0) return;
        for (let i = 0; i < K; ++i) {
          const assigned = points.filter((_, j) => assignments[j] === i);
          if (assigned.length > 0) {
            let sx = 0, sy = 0, sz = 0;
            for (const p of assigned) {
              sx += p.x; sy += p.y; sz += p.z;
            }
            centroids[i] = {
              x: sx/assigned.length,
              y: sy/assigned.length,
              z: sz/assigned.length
            };
          }
        }
        // Update centroid visuals
        while (centroidGroup.children.length > 0) {
          centroidGroup.remove(centroidGroup.children[0]);
        }
        for (let i = 0; i < K; ++i) {
          const c = centroids[i];
          const geometry = new THREE.SphereGeometry(8, 16, 16);
          const material = new THREE.MeshStandardMaterial({ color: centroidColors[i % centroidColors.length] });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(c.x, c.y, c.z);
          centroidGroup.add(mesh);
        }
        draw3DPoints();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // --- Reset everything ---
      function resetAll() {
        genPoints();
        assignments = Array(points.length).fill(-1);
        draw3DPoints();
        while (centroidGroup && centroidGroup.children.length > 0) {
          centroidGroup.remove(centroidGroup.children[0]);
        }
        centroids = [];
      }

      // --- Event Listeners ---
  btnReset.onclick = resetAll;
  numPointsInput.onchange = resetAll;
  btnPlace.onclick = placeCentroids;
  btnMatch.onclick = matchPoints;
  btnMove.onclick = moveCentroids;

      // --- Initial State ---
      setup3D();
      resetAll();
      animate();
    });
  </script>
</body>
</html>
